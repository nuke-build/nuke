// Generated from https://github.com/nuke-build/nuke/blob/master/source/Nuke.Common/Tools/ReportGenerator/ReportGenerator.json

using JetBrains.Annotations;
using Newtonsoft.Json;
using Nuke.Common;
using Nuke.Common.Tooling;
using Nuke.Common.Tools;
using Nuke.Common.Utilities.Collections;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Text;

namespace Nuke.Common.Tools.ReportGenerator;

/// <summary><p>ReportGenerator converts XML reports generated by OpenCover, PartCover, dotCover, Visual Studio, NCover or Cobertura into human readable reports in various formats.</p><p>The reports do not only show the coverage quota, but also include the source code and visualize which lines have been covered.</p><p>ReportGenerator supports merging several reports into one. It is also possible to pass one XML file containing several reports to ReportGenerator (e.g. a build log file).</p><p>The following <a href="https://github.com/danielpalme/ReportGenerator/wiki/Output-formats">output formats</a> are supported by ReportGenerator:<ul><li>HTML, HTMLSummary, HTMLInline, HTMLChart, <a href="https://en.wikipedia.org/wiki/MHTML">MHTML</a></li><li>XML, XMLSummary</li><li>Latex, LatexSummary</li><li>TextSummary</li><li>CsvSummary</li><li>PngChart</li><li>Badges</li><li><a href="https://github.com/danielpalme/ReportGenerator/wiki/Custom-reports">Custom reports</a></li></ul></p><p>Compatibility:<ul><li><a href="https://github.com/OpenCover/opencover">OpenCover</a></li><li><a href="https://github.com/sawilde/partcover.net4">PartCover 4.0</a></li><li><a href="http://sourceforge.net/projects/partcover">PartCover 2.2, 2.3</a></li><li><a href="https://www.jetbrains.com/dotcover/help/dotCover__Console_Runner_Commands.html">dotCover</a> (/ReportType=DetailedXML)</li><li>Visual Studio (<a href="https://github.com/danielpalme/ReportGenerator/wiki/Visual-Studio-Coverage-Tools#vstestconsoleexe">vstest.console.exe</a>, <a href="https://github.com/danielpalme/ReportGenerator/wiki/Visual-Studio-Coverage-Tools#codecoverageexe">CodeCoverage.exe</a>)</li><li><a href="http://www.ncover.com/download/current">NCover</a> (tested version 1.5.8, other versions may not work)</li><li><a href="https://github.com/cobertura/cobertura">Cobertura</a></li><li>Mono (<a href="http://www.mono-project.com/docs/debug+profile/profile/profiler/#analyzing-the-profile-data">mprof-report</a>)</li></ul></p><p>For more details, visit the <a href="https://github.com/danielpalme/ReportGenerator">official website</a>.</p></summary>
[PublicAPI]
[ExcludeFromCodeCoverage]
[NuGetPackageRequirement(PackageId)]
[NuGetTool(Id = PackageId, Executable = PackageExecutable)]
public partial class ReportGeneratorTasks : ToolTasks, IRequireNuGetPackage
{
    public static string ReportGeneratorPath => new ReportGeneratorTasks().GetToolPath();
    public const string PackageId = "ReportGenerator";
    public const string PackageExecutable = "ReportGenerator.dll|ReportGenerator.exe";
    /// <summary><p>ReportGenerator converts XML reports generated by OpenCover, PartCover, dotCover, Visual Studio, NCover or Cobertura into human readable reports in various formats.</p><p>The reports do not only show the coverage quota, but also include the source code and visualize which lines have been covered.</p><p>ReportGenerator supports merging several reports into one. It is also possible to pass one XML file containing several reports to ReportGenerator (e.g. a build log file).</p><p>The following <a href="https://github.com/danielpalme/ReportGenerator/wiki/Output-formats">output formats</a> are supported by ReportGenerator:<ul><li>HTML, HTMLSummary, HTMLInline, HTMLChart, <a href="https://en.wikipedia.org/wiki/MHTML">MHTML</a></li><li>XML, XMLSummary</li><li>Latex, LatexSummary</li><li>TextSummary</li><li>CsvSummary</li><li>PngChart</li><li>Badges</li><li><a href="https://github.com/danielpalme/ReportGenerator/wiki/Custom-reports">Custom reports</a></li></ul></p><p>Compatibility:<ul><li><a href="https://github.com/OpenCover/opencover">OpenCover</a></li><li><a href="https://github.com/sawilde/partcover.net4">PartCover 4.0</a></li><li><a href="http://sourceforge.net/projects/partcover">PartCover 2.2, 2.3</a></li><li><a href="https://www.jetbrains.com/dotcover/help/dotCover__Console_Runner_Commands.html">dotCover</a> (/ReportType=DetailedXML)</li><li>Visual Studio (<a href="https://github.com/danielpalme/ReportGenerator/wiki/Visual-Studio-Coverage-Tools#vstestconsoleexe">vstest.console.exe</a>, <a href="https://github.com/danielpalme/ReportGenerator/wiki/Visual-Studio-Coverage-Tools#codecoverageexe">CodeCoverage.exe</a>)</li><li><a href="http://www.ncover.com/download/current">NCover</a> (tested version 1.5.8, other versions may not work)</li><li><a href="https://github.com/cobertura/cobertura">Cobertura</a></li><li>Mono (<a href="http://www.mono-project.com/docs/debug+profile/profile/profiler/#analyzing-the-profile-data">mprof-report</a>)</li></ul></p><p>For more details, visit the <a href="https://github.com/danielpalme/ReportGenerator">official website</a>.</p></summary>
    public static IReadOnlyCollection<Output> ReportGenerator(ArgumentStringHandler arguments, string workingDirectory = null, IReadOnlyDictionary<string, string> environmentVariables = null, int? timeout = null, bool? logOutput = null, bool? logInvocation = null, Action<OutputType, string> logger = null, Func<IProcess, object> exitHandler = null) => new ReportGeneratorTasks().Run(arguments, workingDirectory, environmentVariables, timeout, logOutput, logInvocation, logger, exitHandler);
    /// <summary><p>ReportGenerator converts XML reports generated by OpenCover, PartCover, dotCover, Visual Studio, NCover or Cobertura into human readable reports in various formats.</p><p>The reports do not only show the coverage quota, but also include the source code and visualize which lines have been covered.</p><p>ReportGenerator supports merging several reports into one. It is also possible to pass one XML file containing several reports to ReportGenerator (e.g. a build log file).</p><p>The following <a href="https://github.com/danielpalme/ReportGenerator/wiki/Output-formats">output formats</a> are supported by ReportGenerator:<ul><li>HTML, HTMLSummary, HTMLInline, HTMLChart, <a href="https://en.wikipedia.org/wiki/MHTML">MHTML</a></li><li>XML, XMLSummary</li><li>Latex, LatexSummary</li><li>TextSummary</li><li>CsvSummary</li><li>PngChart</li><li>Badges</li><li><a href="https://github.com/danielpalme/ReportGenerator/wiki/Custom-reports">Custom reports</a></li></ul></p><p>Compatibility:<ul><li><a href="https://github.com/OpenCover/opencover">OpenCover</a></li><li><a href="https://github.com/sawilde/partcover.net4">PartCover 4.0</a></li><li><a href="http://sourceforge.net/projects/partcover">PartCover 2.2, 2.3</a></li><li><a href="https://www.jetbrains.com/dotcover/help/dotCover__Console_Runner_Commands.html">dotCover</a> (/ReportType=DetailedXML)</li><li>Visual Studio (<a href="https://github.com/danielpalme/ReportGenerator/wiki/Visual-Studio-Coverage-Tools#vstestconsoleexe">vstest.console.exe</a>, <a href="https://github.com/danielpalme/ReportGenerator/wiki/Visual-Studio-Coverage-Tools#codecoverageexe">CodeCoverage.exe</a>)</li><li><a href="http://www.ncover.com/download/current">NCover</a> (tested version 1.5.8, other versions may not work)</li><li><a href="https://github.com/cobertura/cobertura">Cobertura</a></li><li>Mono (<a href="http://www.mono-project.com/docs/debug+profile/profile/profiler/#analyzing-the-profile-data">mprof-report</a>)</li></ul></p><p>For more details, visit the <a href="https://github.com/danielpalme/ReportGenerator">official website</a>.</p></summary>
    /// <remarks><p>This is a <a href="http://www.nuke.build/docs/authoring-builds/cli-tools.html#fluent-apis">CLI wrapper with fluent API</a> that allows to modify the following arguments:</p><ul><li><c>-assemblyfilters</c> via <see cref="ReportGeneratorSettings.AssemblyFilters"/></li><li><c>-classfilters</c> via <see cref="ReportGeneratorSettings.ClassFilters"/></li><li><c>-filefilters</c> via <see cref="ReportGeneratorSettings.FileFilters"/></li><li><c>-historydir</c> via <see cref="ReportGeneratorSettings.HistoryDirectory"/></li><li><c>-reports</c> via <see cref="ReportGeneratorSettings.Reports"/></li><li><c>-reporttypes</c> via <see cref="ReportGeneratorSettings.ReportTypes"/></li><li><c>-sourcedirs</c> via <see cref="ReportGeneratorSettings.SourceDirectories"/></li><li><c>-tag</c> via <see cref="ReportGeneratorSettings.Tag"/></li><li><c>-targetdir</c> via <see cref="ReportGeneratorSettings.TargetDirectory"/></li><li><c>-verbosity</c> via <see cref="ReportGeneratorSettings.Verbosity"/></li></ul></remarks>
    public static IReadOnlyCollection<Output> ReportGenerator(ReportGeneratorSettings options = null) => new ReportGeneratorTasks().Run(options);
    /// <summary><p>ReportGenerator converts XML reports generated by OpenCover, PartCover, dotCover, Visual Studio, NCover or Cobertura into human readable reports in various formats.</p><p>The reports do not only show the coverage quota, but also include the source code and visualize which lines have been covered.</p><p>ReportGenerator supports merging several reports into one. It is also possible to pass one XML file containing several reports to ReportGenerator (e.g. a build log file).</p><p>The following <a href="https://github.com/danielpalme/ReportGenerator/wiki/Output-formats">output formats</a> are supported by ReportGenerator:<ul><li>HTML, HTMLSummary, HTMLInline, HTMLChart, <a href="https://en.wikipedia.org/wiki/MHTML">MHTML</a></li><li>XML, XMLSummary</li><li>Latex, LatexSummary</li><li>TextSummary</li><li>CsvSummary</li><li>PngChart</li><li>Badges</li><li><a href="https://github.com/danielpalme/ReportGenerator/wiki/Custom-reports">Custom reports</a></li></ul></p><p>Compatibility:<ul><li><a href="https://github.com/OpenCover/opencover">OpenCover</a></li><li><a href="https://github.com/sawilde/partcover.net4">PartCover 4.0</a></li><li><a href="http://sourceforge.net/projects/partcover">PartCover 2.2, 2.3</a></li><li><a href="https://www.jetbrains.com/dotcover/help/dotCover__Console_Runner_Commands.html">dotCover</a> (/ReportType=DetailedXML)</li><li>Visual Studio (<a href="https://github.com/danielpalme/ReportGenerator/wiki/Visual-Studio-Coverage-Tools#vstestconsoleexe">vstest.console.exe</a>, <a href="https://github.com/danielpalme/ReportGenerator/wiki/Visual-Studio-Coverage-Tools#codecoverageexe">CodeCoverage.exe</a>)</li><li><a href="http://www.ncover.com/download/current">NCover</a> (tested version 1.5.8, other versions may not work)</li><li><a href="https://github.com/cobertura/cobertura">Cobertura</a></li><li>Mono (<a href="http://www.mono-project.com/docs/debug+profile/profile/profiler/#analyzing-the-profile-data">mprof-report</a>)</li></ul></p><p>For more details, visit the <a href="https://github.com/danielpalme/ReportGenerator">official website</a>.</p></summary>
    /// <remarks><p>This is a <a href="http://www.nuke.build/docs/authoring-builds/cli-tools.html#fluent-apis">CLI wrapper with fluent API</a> that allows to modify the following arguments:</p><ul><li><c>-assemblyfilters</c> via <see cref="ReportGeneratorSettings.AssemblyFilters"/></li><li><c>-classfilters</c> via <see cref="ReportGeneratorSettings.ClassFilters"/></li><li><c>-filefilters</c> via <see cref="ReportGeneratorSettings.FileFilters"/></li><li><c>-historydir</c> via <see cref="ReportGeneratorSettings.HistoryDirectory"/></li><li><c>-reports</c> via <see cref="ReportGeneratorSettings.Reports"/></li><li><c>-reporttypes</c> via <see cref="ReportGeneratorSettings.ReportTypes"/></li><li><c>-sourcedirs</c> via <see cref="ReportGeneratorSettings.SourceDirectories"/></li><li><c>-tag</c> via <see cref="ReportGeneratorSettings.Tag"/></li><li><c>-targetdir</c> via <see cref="ReportGeneratorSettings.TargetDirectory"/></li><li><c>-verbosity</c> via <see cref="ReportGeneratorSettings.Verbosity"/></li></ul></remarks>
    public static IReadOnlyCollection<Output> ReportGenerator(Configure<ReportGeneratorSettings> configurator) => new ReportGeneratorTasks().Run(configurator.Invoke(new ReportGeneratorSettings()));
    /// <summary><p>ReportGenerator converts XML reports generated by OpenCover, PartCover, dotCover, Visual Studio, NCover or Cobertura into human readable reports in various formats.</p><p>The reports do not only show the coverage quota, but also include the source code and visualize which lines have been covered.</p><p>ReportGenerator supports merging several reports into one. It is also possible to pass one XML file containing several reports to ReportGenerator (e.g. a build log file).</p><p>The following <a href="https://github.com/danielpalme/ReportGenerator/wiki/Output-formats">output formats</a> are supported by ReportGenerator:<ul><li>HTML, HTMLSummary, HTMLInline, HTMLChart, <a href="https://en.wikipedia.org/wiki/MHTML">MHTML</a></li><li>XML, XMLSummary</li><li>Latex, LatexSummary</li><li>TextSummary</li><li>CsvSummary</li><li>PngChart</li><li>Badges</li><li><a href="https://github.com/danielpalme/ReportGenerator/wiki/Custom-reports">Custom reports</a></li></ul></p><p>Compatibility:<ul><li><a href="https://github.com/OpenCover/opencover">OpenCover</a></li><li><a href="https://github.com/sawilde/partcover.net4">PartCover 4.0</a></li><li><a href="http://sourceforge.net/projects/partcover">PartCover 2.2, 2.3</a></li><li><a href="https://www.jetbrains.com/dotcover/help/dotCover__Console_Runner_Commands.html">dotCover</a> (/ReportType=DetailedXML)</li><li>Visual Studio (<a href="https://github.com/danielpalme/ReportGenerator/wiki/Visual-Studio-Coverage-Tools#vstestconsoleexe">vstest.console.exe</a>, <a href="https://github.com/danielpalme/ReportGenerator/wiki/Visual-Studio-Coverage-Tools#codecoverageexe">CodeCoverage.exe</a>)</li><li><a href="http://www.ncover.com/download/current">NCover</a> (tested version 1.5.8, other versions may not work)</li><li><a href="https://github.com/cobertura/cobertura">Cobertura</a></li><li>Mono (<a href="http://www.mono-project.com/docs/debug+profile/profile/profiler/#analyzing-the-profile-data">mprof-report</a>)</li></ul></p><p>For more details, visit the <a href="https://github.com/danielpalme/ReportGenerator">official website</a>.</p></summary>
    /// <remarks><p>This is a <a href="http://www.nuke.build/docs/authoring-builds/cli-tools.html#fluent-apis">CLI wrapper with fluent API</a> that allows to modify the following arguments:</p><ul><li><c>-assemblyfilters</c> via <see cref="ReportGeneratorSettings.AssemblyFilters"/></li><li><c>-classfilters</c> via <see cref="ReportGeneratorSettings.ClassFilters"/></li><li><c>-filefilters</c> via <see cref="ReportGeneratorSettings.FileFilters"/></li><li><c>-historydir</c> via <see cref="ReportGeneratorSettings.HistoryDirectory"/></li><li><c>-reports</c> via <see cref="ReportGeneratorSettings.Reports"/></li><li><c>-reporttypes</c> via <see cref="ReportGeneratorSettings.ReportTypes"/></li><li><c>-sourcedirs</c> via <see cref="ReportGeneratorSettings.SourceDirectories"/></li><li><c>-tag</c> via <see cref="ReportGeneratorSettings.Tag"/></li><li><c>-targetdir</c> via <see cref="ReportGeneratorSettings.TargetDirectory"/></li><li><c>-verbosity</c> via <see cref="ReportGeneratorSettings.Verbosity"/></li></ul></remarks>
    public static IEnumerable<(ReportGeneratorSettings Settings, IReadOnlyCollection<Output> Output)> ReportGenerator(CombinatorialConfigure<ReportGeneratorSettings> configurator, int degreeOfParallelism = 1, bool completeOnFailure = false) => configurator.Invoke(ReportGenerator, degreeOfParallelism, completeOnFailure);
}
#region ReportGeneratorSettings
/// <summary>Used within <see cref="ReportGeneratorTasks"/>.</summary>
[PublicAPI]
[ExcludeFromCodeCoverage]
[TypeConverter(typeof(TypeConverter<ReportGeneratorSettings>))]
[Command(Type = typeof(ReportGeneratorTasks), Command = nameof(ReportGeneratorTasks.ReportGenerator))]
public partial class ReportGeneratorSettings : ToolOptions, IToolOptionsWithFramework
{
    /// <summary>The coverage reports that should be parsed (separated by semicolon). Wildcards are allowed.</summary>
    [Argument(Format = "-reports:{value}", Separator = ";")] public IReadOnlyList<string> Reports => Get<List<string>>(() => Reports);
    /// <summary>The directory where the generated report should be saved.</summary>
    [Argument(Format = "-targetdir:{value}")] public string TargetDirectory => Get<string>(() => TargetDirectory);
    /// <summary>The output formats and scope (separated by semicolon). Default is Html.</summary>
    [Argument(Format = "-reporttypes:{value}", Separator = ";")] public IReadOnlyList<ReportTypes> ReportTypes => Get<List<ReportTypes>>(() => ReportTypes);
    /// <summary>Optional directories which contain the corresponding source code (separated by semicolon). The source files are used if coverage report contains classes without path information.</summary>
    [Argument(Format = "-sourcedirs:{value}", Separator = ";")] public IReadOnlyList<string> SourceDirectories => Get<List<string>>(() => SourceDirectories);
    /// <summary>Optional directory for storing persistent coverage information. Can be used in future reports to show coverage evolution.</summary>
    [Argument(Format = "-historydir:{value}")] public string HistoryDirectory => Get<string>(() => HistoryDirectory);
    /// <summary>Optional list of assemblies that should be included (+) or excluded (-) in the report. Default is +*.</summary>
    [Argument(Format = "-assemblyfilters:{value}", Separator = ";")] public IReadOnlyList<string> AssemblyFilters => Get<List<string>>(() => AssemblyFilters);
    /// <summary>Optional list of classes that should be included (+) or excluded (-) in the report. Exclusion filters take precedence over inclusion filters. Wildcards are allowed. Default is +*.</summary>
    [Argument(Format = "-classfilters:{value}", Separator = ";")] public IReadOnlyList<string> ClassFilters => Get<List<string>>(() => ClassFilters);
    /// <summary>Optional list of files that should be included (+) or excluded (-) in the report. Exclusion filters take precedence over inclusion filters. Wildcards are allowed. Default is +*.</summary>
    [Argument(Format = "-filefilters:{value}", Separator = ";")] public IReadOnlyList<string> FileFilters => Get<List<string>>(() => FileFilters);
    /// <summary>Optional tag or build version.</summary>
    [Argument(Format = "-tag:{value}")] public string Tag => Get<string>(() => Tag);
    /// <summary>The verbosity level of the log messages. Default is Verbose.</summary>
    [Argument(Format = "-verbosity:{value}")] public ReportGeneratorVerbosity Verbosity => Get<ReportGeneratorVerbosity>(() => Verbosity);
}
#endregion
#region ReportGeneratorSettingsExtensions
/// <summary>Used within <see cref="ReportGeneratorTasks"/>.</summary>
[PublicAPI]
[ExcludeFromCodeCoverage]
public static partial class ReportGeneratorSettingsExtensions
{
    #region Reports
    /// <inheritdoc cref="ReportGeneratorSettings.Reports"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.Reports))]
    public static T SetReports<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.Reports, v));
    /// <inheritdoc cref="ReportGeneratorSettings.Reports"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.Reports))]
    public static T SetReports<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.Reports, v));
    /// <inheritdoc cref="ReportGeneratorSettings.Reports"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.Reports))]
    public static T AddReports<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.AddCollection(() => o.Reports, v));
    /// <inheritdoc cref="ReportGeneratorSettings.Reports"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.Reports))]
    public static T AddReports<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.AddCollection(() => o.Reports, v));
    /// <inheritdoc cref="ReportGeneratorSettings.Reports"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.Reports))]
    public static T RemoveReports<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.RemoveCollection(() => o.Reports, v));
    /// <inheritdoc cref="ReportGeneratorSettings.Reports"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.Reports))]
    public static T RemoveReports<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.RemoveCollection(() => o.Reports, v));
    /// <inheritdoc cref="ReportGeneratorSettings.Reports"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.Reports))]
    public static T ClearReports<T>(this T o) where T : ReportGeneratorSettings => o.Modify(b => b.ClearCollection(() => o.Reports));
    #endregion
    #region TargetDirectory
    /// <inheritdoc cref="ReportGeneratorSettings.TargetDirectory"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.TargetDirectory))]
    public static T SetTargetDirectory<T>(this T o, string v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.TargetDirectory, v));
    /// <inheritdoc cref="ReportGeneratorSettings.TargetDirectory"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.TargetDirectory))]
    public static T ResetTargetDirectory<T>(this T o) where T : ReportGeneratorSettings => o.Modify(b => b.Remove(() => o.TargetDirectory));
    #endregion
    #region ReportTypes
    /// <inheritdoc cref="ReportGeneratorSettings.ReportTypes"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ReportTypes))]
    public static T SetReportTypes<T>(this T o, params ReportTypes[] v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.ReportTypes, v));
    /// <inheritdoc cref="ReportGeneratorSettings.ReportTypes"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ReportTypes))]
    public static T SetReportTypes<T>(this T o, IEnumerable<ReportTypes> v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.ReportTypes, v));
    /// <inheritdoc cref="ReportGeneratorSettings.ReportTypes"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ReportTypes))]
    public static T AddReportTypes<T>(this T o, params ReportTypes[] v) where T : ReportGeneratorSettings => o.Modify(b => b.AddCollection(() => o.ReportTypes, v));
    /// <inheritdoc cref="ReportGeneratorSettings.ReportTypes"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ReportTypes))]
    public static T AddReportTypes<T>(this T o, IEnumerable<ReportTypes> v) where T : ReportGeneratorSettings => o.Modify(b => b.AddCollection(() => o.ReportTypes, v));
    /// <inheritdoc cref="ReportGeneratorSettings.ReportTypes"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ReportTypes))]
    public static T RemoveReportTypes<T>(this T o, params ReportTypes[] v) where T : ReportGeneratorSettings => o.Modify(b => b.RemoveCollection(() => o.ReportTypes, v));
    /// <inheritdoc cref="ReportGeneratorSettings.ReportTypes"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ReportTypes))]
    public static T RemoveReportTypes<T>(this T o, IEnumerable<ReportTypes> v) where T : ReportGeneratorSettings => o.Modify(b => b.RemoveCollection(() => o.ReportTypes, v));
    /// <inheritdoc cref="ReportGeneratorSettings.ReportTypes"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ReportTypes))]
    public static T ClearReportTypes<T>(this T o) where T : ReportGeneratorSettings => o.Modify(b => b.ClearCollection(() => o.ReportTypes));
    #endregion
    #region SourceDirectories
    /// <inheritdoc cref="ReportGeneratorSettings.SourceDirectories"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.SourceDirectories))]
    public static T SetSourceDirectories<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.SourceDirectories, v));
    /// <inheritdoc cref="ReportGeneratorSettings.SourceDirectories"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.SourceDirectories))]
    public static T SetSourceDirectories<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.SourceDirectories, v));
    /// <inheritdoc cref="ReportGeneratorSettings.SourceDirectories"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.SourceDirectories))]
    public static T AddSourceDirectories<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.AddCollection(() => o.SourceDirectories, v));
    /// <inheritdoc cref="ReportGeneratorSettings.SourceDirectories"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.SourceDirectories))]
    public static T AddSourceDirectories<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.AddCollection(() => o.SourceDirectories, v));
    /// <inheritdoc cref="ReportGeneratorSettings.SourceDirectories"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.SourceDirectories))]
    public static T RemoveSourceDirectories<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.RemoveCollection(() => o.SourceDirectories, v));
    /// <inheritdoc cref="ReportGeneratorSettings.SourceDirectories"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.SourceDirectories))]
    public static T RemoveSourceDirectories<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.RemoveCollection(() => o.SourceDirectories, v));
    /// <inheritdoc cref="ReportGeneratorSettings.SourceDirectories"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.SourceDirectories))]
    public static T ClearSourceDirectories<T>(this T o) where T : ReportGeneratorSettings => o.Modify(b => b.ClearCollection(() => o.SourceDirectories));
    #endregion
    #region HistoryDirectory
    /// <inheritdoc cref="ReportGeneratorSettings.HistoryDirectory"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.HistoryDirectory))]
    public static T SetHistoryDirectory<T>(this T o, string v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.HistoryDirectory, v));
    /// <inheritdoc cref="ReportGeneratorSettings.HistoryDirectory"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.HistoryDirectory))]
    public static T ResetHistoryDirectory<T>(this T o) where T : ReportGeneratorSettings => o.Modify(b => b.Remove(() => o.HistoryDirectory));
    #endregion
    #region AssemblyFilters
    /// <inheritdoc cref="ReportGeneratorSettings.AssemblyFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.AssemblyFilters))]
    public static T SetAssemblyFilters<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.AssemblyFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.AssemblyFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.AssemblyFilters))]
    public static T SetAssemblyFilters<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.AssemblyFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.AssemblyFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.AssemblyFilters))]
    public static T AddAssemblyFilters<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.AddCollection(() => o.AssemblyFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.AssemblyFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.AssemblyFilters))]
    public static T AddAssemblyFilters<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.AddCollection(() => o.AssemblyFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.AssemblyFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.AssemblyFilters))]
    public static T RemoveAssemblyFilters<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.RemoveCollection(() => o.AssemblyFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.AssemblyFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.AssemblyFilters))]
    public static T RemoveAssemblyFilters<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.RemoveCollection(() => o.AssemblyFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.AssemblyFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.AssemblyFilters))]
    public static T ClearAssemblyFilters<T>(this T o) where T : ReportGeneratorSettings => o.Modify(b => b.ClearCollection(() => o.AssemblyFilters));
    #endregion
    #region ClassFilters
    /// <inheritdoc cref="ReportGeneratorSettings.ClassFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ClassFilters))]
    public static T SetClassFilters<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.ClassFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.ClassFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ClassFilters))]
    public static T SetClassFilters<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.ClassFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.ClassFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ClassFilters))]
    public static T AddClassFilters<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.AddCollection(() => o.ClassFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.ClassFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ClassFilters))]
    public static T AddClassFilters<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.AddCollection(() => o.ClassFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.ClassFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ClassFilters))]
    public static T RemoveClassFilters<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.RemoveCollection(() => o.ClassFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.ClassFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ClassFilters))]
    public static T RemoveClassFilters<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.RemoveCollection(() => o.ClassFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.ClassFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.ClassFilters))]
    public static T ClearClassFilters<T>(this T o) where T : ReportGeneratorSettings => o.Modify(b => b.ClearCollection(() => o.ClassFilters));
    #endregion
    #region FileFilters
    /// <inheritdoc cref="ReportGeneratorSettings.FileFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.FileFilters))]
    public static T SetFileFilters<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.FileFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.FileFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.FileFilters))]
    public static T SetFileFilters<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.FileFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.FileFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.FileFilters))]
    public static T AddFileFilters<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.AddCollection(() => o.FileFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.FileFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.FileFilters))]
    public static T AddFileFilters<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.AddCollection(() => o.FileFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.FileFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.FileFilters))]
    public static T RemoveFileFilters<T>(this T o, params string[] v) where T : ReportGeneratorSettings => o.Modify(b => b.RemoveCollection(() => o.FileFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.FileFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.FileFilters))]
    public static T RemoveFileFilters<T>(this T o, IEnumerable<string> v) where T : ReportGeneratorSettings => o.Modify(b => b.RemoveCollection(() => o.FileFilters, v));
    /// <inheritdoc cref="ReportGeneratorSettings.FileFilters"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.FileFilters))]
    public static T ClearFileFilters<T>(this T o) where T : ReportGeneratorSettings => o.Modify(b => b.ClearCollection(() => o.FileFilters));
    #endregion
    #region Tag
    /// <inheritdoc cref="ReportGeneratorSettings.Tag"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.Tag))]
    public static T SetTag<T>(this T o, string v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.Tag, v));
    /// <inheritdoc cref="ReportGeneratorSettings.Tag"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.Tag))]
    public static T ResetTag<T>(this T o) where T : ReportGeneratorSettings => o.Modify(b => b.Remove(() => o.Tag));
    #endregion
    #region Verbosity
    /// <inheritdoc cref="ReportGeneratorSettings.Verbosity"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.Verbosity))]
    public static T SetVerbosity<T>(this T o, ReportGeneratorVerbosity v) where T : ReportGeneratorSettings => o.Modify(b => b.Set(() => o.Verbosity, v));
    /// <inheritdoc cref="ReportGeneratorSettings.Verbosity"/>
    [Pure] [Builder(Type = typeof(ReportGeneratorSettings), Property = nameof(ReportGeneratorSettings.Verbosity))]
    public static T ResetVerbosity<T>(this T o) where T : ReportGeneratorSettings => o.Modify(b => b.Remove(() => o.Verbosity));
    #endregion
}
#endregion
#region ReportTypes
/// <summary>Used within <see cref="ReportGeneratorTasks"/>.</summary>
[PublicAPI]
[Serializable]
[ExcludeFromCodeCoverage]
[TypeConverter(typeof(TypeConverter<ReportTypes>))]
public partial class ReportTypes : Enumeration
{
    public static ReportTypes Badges = (ReportTypes) "Badges";
    public static ReportTypes Cobertura = (ReportTypes) "Cobertura";
    public static ReportTypes Clover = (ReportTypes) "Clover";
    public static ReportTypes CsvSummary = (ReportTypes) "CsvSummary";
    public static ReportTypes Html = (ReportTypes) "Html";
    public static ReportTypes Html_Light = (ReportTypes) "Html_Light";
    public static ReportTypes Html_Dark = (ReportTypes) "Html_Dark";
    public static ReportTypes Html_BlueRed = (ReportTypes) "Html_BlueRed";
    public static ReportTypes HtmlInline = (ReportTypes) "HtmlInline";
    public static ReportTypes HtmlInline_AzurePipelines = (ReportTypes) "HtmlInline_AzurePipelines";
    public static ReportTypes HtmlInline_AzurePipelines_Light = (ReportTypes) "HtmlInline_AzurePipelines_Light";
    public static ReportTypes HtmlInline_AzurePipelines_Dark = (ReportTypes) "HtmlInline_AzurePipelines_Dark";
    public static ReportTypes HtmlChart = (ReportTypes) "HtmlChart";
    public static ReportTypes HtmlSummary = (ReportTypes) "HtmlSummary";
    public static ReportTypes Html_BlueRed_Summary = (ReportTypes) "Html_BlueRed_Summary";
    public static ReportTypes JsonSummary = (ReportTypes) "JsonSummary";
    public static ReportTypes Latex = (ReportTypes) "Latex";
    public static ReportTypes LatexSummary = (ReportTypes) "LatexSummary";
    public static ReportTypes lcov = (ReportTypes) "lcov";
    public static ReportTypes MarkdownSummary = (ReportTypes) "MarkdownSummary";
    public static ReportTypes MarkdownSummaryGithub = (ReportTypes) "MarkdownSummaryGithub";
    public static ReportTypes MarkdownDeltaSummary = (ReportTypes) "MarkdownDeltaSummary";
    public static ReportTypes OpenCover = (ReportTypes) "OpenCover";
    public static ReportTypes MHtml = (ReportTypes) "MHtml";
    public static ReportTypes PngChart = (ReportTypes) "PngChart";
    public static ReportTypes TextSummary = (ReportTypes) "TextSummary";
    public static ReportTypes Xml = (ReportTypes) "Xml";
    public static ReportTypes XmlSummary = (ReportTypes) "XmlSummary";
    public static ReportTypes SonarQube = (ReportTypes) "SonarQube";
    public static ReportTypes TeamCitySummary = (ReportTypes) "TeamCitySummary";
    public static implicit operator ReportTypes(string value)
    {
        return new ReportTypes { Value = value };
    }
}
#endregion
#region ReportGeneratorVerbosity
/// <summary>Used within <see cref="ReportGeneratorTasks"/>.</summary>
[PublicAPI]
[Serializable]
[ExcludeFromCodeCoverage]
[TypeConverter(typeof(TypeConverter<ReportGeneratorVerbosity>))]
public partial class ReportGeneratorVerbosity : Enumeration
{
    public static ReportGeneratorVerbosity Off = (ReportGeneratorVerbosity) "Off";
    public static ReportGeneratorVerbosity Verbose = (ReportGeneratorVerbosity) "Verbose";
    public static ReportGeneratorVerbosity Info = (ReportGeneratorVerbosity) "Info";
    public static ReportGeneratorVerbosity Warning = (ReportGeneratorVerbosity) "Warning";
    public static ReportGeneratorVerbosity Error = (ReportGeneratorVerbosity) "Error";
    public static implicit operator ReportGeneratorVerbosity(string value)
    {
        return new ReportGeneratorVerbosity { Value = value };
    }
}
#endregion
