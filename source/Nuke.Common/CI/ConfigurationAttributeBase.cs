// Copyright 2019 Maintainers of NUKE.
// Distributed under the MIT License.
// https://github.com/nuke-build/nuke/blob/master/LICENSE

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using JetBrains.Annotations;
using Nuke.Common.Execution;
using Nuke.Common.IO;
using Nuke.Common.Tooling;
using Nuke.Common.Tools.DotNet;
using Nuke.Common.Utilities;
using Nuke.Common.Utilities.Collections;
using static Nuke.Common.IO.FileSystemTasks;
using static Nuke.Common.IO.PathConstruction;

namespace Nuke.Common.CI
{
    [PublicAPI]
    [AttributeUsage(AttributeTargets.Class)]
    public abstract class ConfigurationAttributeBase : Attribute, IOnBeforeLogo, IOnAfterLogo, IOnBuildFinished
    {
        public const string ConfigurationParameterName = "configure-build-server";

        public bool AutoGenerate { get; set; } = true;

        public bool ShutdownDotNetBuildServer { get; set; } = true;

        protected abstract HostType HostType { get; }
        protected abstract IEnumerable<string> GeneratedFiles { get; }
        protected abstract IEnumerable<string> RelevantTargetNames { get; }
        protected abstract IEnumerable<string> IrrelevantTargetNames { get; }

        protected virtual string PowerShellScript =>
            NukeBuild.RootDirectory.GlobFiles("build.ps1", "*/build.ps1")
                .Select(x => (WinRelativePath) GetRelativePath(NukeBuild.RootDirectory, x))
                .FirstOrDefault().NotNull("PowerShellScript != null");

        protected virtual string BashScript =>
            NukeBuild.RootDirectory.GlobFiles("build.sh", "*/build.sh")
                .Select(x => (UnixRelativePath) GetRelativePath(NukeBuild.RootDirectory, x))
                .FirstOrDefault().NotNull("BashScript != null");

        public void OnBeforeLogo(NukeBuild build, IReadOnlyCollection<ExecutableTarget> executableTargets)
        {
            if (!EnvironmentInfo.GetParameter<bool>(ConfigurationParameterName) ||
                NukeBuild.Host != HostType)
                return;

            ControlFlow.Assert(NukeBuild.RootDirectory != null, "NukeBuild.RootDirectory != null");

            var relevantTargets = RelevantTargetNames
                .SelectMany(x => ExecutionPlanner.GetExecutionPlan(executableTargets, new[] { x }))
                .Distinct()
                .Where(x => !IrrelevantTargetNames.Contains(x.Name)).ToList();

            using (var writer = CreateWriter())
            {
                WriteAutoGenerationComment(writer);
                var configuration = GetConfiguration(build, relevantTargets);
                configuration.Write(writer);
            }

            Environment.Exit(0);
        }

        protected virtual void WriteAutoGenerationComment(CustomFileWriter writer)
        {
            writer.WriteComment("------------------------------------------------------------------------------");
            writer.WriteComment("<auto-generated>");
            writer.WriteComment();
            writer.WriteComment("    This code was generated.");
            writer.WriteComment();
            writer.WriteComment("    - To turn off auto-generation set:");
            writer.WriteComment();
            writer.WriteComment($"        [{GetType().Name.TrimEnd(nameof(Attribute))} ({nameof(AutoGenerate)} = false)]");
            writer.WriteComment();
            writer.WriteComment("    - To trigger manual generation invoke:");
            writer.WriteComment();
            writer.WriteComment($"        nuke --{ConfigurationParameterName} --host {HostType}");
            writer.WriteComment();
            writer.WriteComment("</auto-generated>");
            writer.WriteComment("------------------------------------------------------------------------------");
            writer.WriteLine();
        }

        public void OnAfterLogo(
            NukeBuild build,
            IReadOnlyCollection<ExecutableTarget> executableTargets,
            IReadOnlyCollection<ExecutableTarget> executionPlan)
        {
            if (!AutoGenerate || NukeBuild.IsServerBuild)
                return;

            GeneratedFiles.ForEach(EnsureExistingParentDirectory);

            // TODO: necessary?
            Logger.LogLevel = LogLevel.Trace;
            var previousHashes = GeneratedFiles
                .Where(File.Exists)
                .ToDictionary(x => x, GetFileHash);

            var assembly = Assembly.GetEntryAssembly().NotNull("assembly != null");
            ProcessTasks.StartProcess(
                    assembly.Location,
                    $"--{ConfigurationParameterName} --host {HostType}",
                    logInvocation: false,
                    logOutput: true)
                .AssertZeroExitCode();

            var changedFiles = GeneratedFiles
                .Where(x => GetFileHash(x) != previousHashes.GetValueOrDefault(x))
                .Select(x => GetRelativePath(NukeBuild.RootDirectory, x)).ToList();

            if (changedFiles.Count > 0)
            {
                Logger.Warn($"{HostType} configuration files have changed.");
                changedFiles.ForEach(x => Logger.Trace($"Updated {x}"));
            }
        }

        public void OnBuildFinished(NukeBuild build)
        {
            if (NukeBuild.Host != HostType)
                return;

            // Note https://github.com/dotnet/cli/issues/11424
            if (ShutdownDotNetBuildServer)
                DotNetTasks.DotNet("build-server shutdown");

            OnBuildFinishedInternal(build);
        }

        protected abstract CustomFileWriter CreateWriter();
        protected abstract ConfigurationEntity GetConfiguration(NukeBuild build, IReadOnlyCollection<ExecutableTarget> relevantTargets);

        protected virtual void OnBuildFinishedInternal(NukeBuild build)
        {
        }
    }
}
