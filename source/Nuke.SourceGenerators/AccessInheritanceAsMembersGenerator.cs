// Copyright 2023 Maintainers of NUKE.
// Distributed under the MIT License.
// https://github.com/nuke-build/nuke/blob/master/LICENSE

using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Nuke.Common.Utilities.Collections;

namespace Nuke.SourceGenerators;

[Generator]
public class AccessInheritanceAsMembersGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
        try
        {
            if (GenerateSolutionSource(context.Compilation) is { Length: > 0 } generatedSource)
            {
                context.AddSource(nameof(AccessInheritanceAsMembersGenerator), generatedSource);
            }
        }
        catch (Exception exception)
        {
            var diagnostic = Diagnostic.Create(
                "NUKE002",
                nameof(AccessInheritanceAsMembersGenerator),
                exception.Message,
                DiagnosticSeverity.Error,
                DiagnosticSeverity.Error,
                isEnabledByDefault: true,
                warningLevel: 0);
            context.ReportDiagnostic(diagnostic);
        }
    }

    private string GenerateSolutionSource(Compilation compilation)
    {
        var allTypes = compilation.Assembly.GlobalNamespace.GetAllTypes();
        var nukeBuildInterfaceType = compilation.GetTypeByMetadataName("Nuke.Common.INukeBuild");
        var generatedSource = new StringBuilder();
        
        foreach (var type in allTypes)
        {
            // must be a class
            if (type.TypeKind != TypeKind.Class)
                continue;
            
            // must not be abstract, only have a look at concrete classes
            if (type.IsAbstract)
                continue;
            
            // must inherit from INukeBuild
            if (!type.AllInterfaces.Any(x => x.Equals(nukeBuildInterfaceType)))
                continue;
            
            // must be partial
            if (!type.DeclaringSyntaxReferences.Any(
                    x => x.GetSyntax() is ClassDeclarationSyntax classDeclarationSyntax &&
                         classDeclarationSyntax.Modifiers.Any(y => y.Kind() == SyntaxKind.PartialKeyword)))
                continue;
            
            
            // generate a partial class with the same name
            switch (type.DeclaredAccessibility)
            {
                case Accessibility.Public:
                    generatedSource.Append("public ");
                    break;
                case Accessibility.Protected:
                    generatedSource.Append("protected ");
                    break;
                case Accessibility.Internal:
                    generatedSource.Append("internal ");
                    break;
                case Accessibility.ProtectedAndInternal:
                    generatedSource.Append("protected internal ");
                    break;
                case Accessibility.Private:
                    generatedSource.Append("private ");
                    break;
            }

            generatedSource.Append("partial class ");
            generatedSource.AppendLine(type.Name);
            generatedSource.AppendLine("{");
            // each interface that is not INukeBuild is added as a protected member
            type.AllInterfaces
                .Where(x => !x.Equals(nukeBuildInterfaceType))
                .ForEach(x =>
                {
                    generatedSource.Append("    protected ");
                    generatedSource.Append(x.GetFullName());
                    generatedSource.Append(" ");
                    generatedSource.Append(x.Name);
                    generatedSource.AppendLine("  => this;");
                });
            generatedSource.AppendLine("}");
        }
        
        if (generatedSource.Length > 0)
            generatedSource.Insert(index: 0, "// <auto-generated/>\nusing System;\n\n");
        
        return generatedSource.Length <= 0 ? null : generatedSource.ToString();
    }
}
