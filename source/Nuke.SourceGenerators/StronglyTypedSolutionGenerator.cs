// Copyright 2023 Maintainers of NUKE.
// Distributed under the MIT License.
// https://github.com/nuke-build/nuke/blob/master/LICENSE

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using JetBrains.Annotations;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Newtonsoft.Json.Linq;
using Nuke.Common;
using Nuke.Common.IO;
using Nuke.Common.ProjectModel;
using Nuke.Common.Utilities;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Nuke.SourceGenerators;

[Generator]
public class StronglyTypedSolutionGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
        try
        {
            if (GenerateSolutionSource(context.Compilation) is { Length: > 0 } generatedSource)
            {
                context.AddSource(nameof(StronglyTypedSolutionGenerator), generatedSource);
            }
        }
        catch (Exception exception)
        {
            var diagnostic = Diagnostic.Create(
                "NUKE001",
                nameof(StronglyTypedSolutionGenerator),
                exception.Message,
                DiagnosticSeverity.Error,
                DiagnosticSeverity.Error,
                isEnabledByDefault: true,
                warningLevel: 0);
            context.ReportDiagnostic(diagnostic);
        }
    }

    private string GenerateSolutionSource(Compilation compilation)
    {
        var allTypes = compilation.Assembly.GlobalNamespace.GetAllTypes();
        var members = allTypes.SelectMany(x => x.GetMembers())
            .Where(x => x is IPropertySymbol or IFieldSymbol)
            .Select(x => (Member: x, AttributeData: x.GetAttributeData("global::Nuke.Common.ProjectModel.SolutionAttribute")))
            .Where(x => x.AttributeData?.NamedArguments.SingleOrDefault(x => x.Key == "GenerateProjects").Value.Value as bool? ?? false)
            .ToList();

        if (members.Count == 0)
            return null;

        var rootDirectory = GetRootDirectoryFrom(compilation);
        var compilationUnit = CompilationUnit()
            .AddUsings(UsingDirective(IdentifierName("Nuke.Common.ProjectModel")));

        foreach (var (member, attributeData) in members)
        {
            var solutionFile = attributeData.ConstructorArguments.FirstOrDefault().Value is string { Length: > 0 } relativeSlnPath
                ? rootDirectory / relativeSlnPath
                : GetSolutionFileFromParametersFile(rootDirectory, member.Name);

            var solution = SolutionSerializer.DeserializeFromFile<Solution>(solutionFile);

            var classDeclaration = GetSolutionFolderDeclaration(member.Name, solution.SolutionFolders, solution.Projects, parent: "_", isSolution: true);
            compilationUnit = compilationUnit
                .AddMembers(member.ContainingType.ContainingNamespace.Equals(compilation.GlobalNamespace, SymbolEqualityComparer.Default)
                    ? NamespaceDeclaration(IdentifierName(member.ContainingType.ContainingNamespace.GetFullName()))
                        .AddMembers(classDeclaration)
                    : classDeclaration);
        }

        return compilationUnit
            .WithLeadingTrivia(ParseLeadingTrivia($"/// <auto-generated/>{Environment.NewLine}"))
            .NormalizeWhitespace()
            .ToFullString();
    }

    [CanBeNull]
    private ClassDeclarationSyntax GetSolutionFolderDeclaration(
        string name,
        IReadOnlyCollection<SolutionFolder> solutionFolders,
        IReadOnlyCollection<Project> projects,
        string parent,
        bool isSolution = false)
    {
        static string GetMemberName([CanBeNull] string name) => name?
            .ReplaceRegex(@"(^[\W^\d]|[\W])", _ => "_")
            .TrimToOne("_");

        static string GetSolutionFolderTypeName(string name, string parent)
            => $"{parent}{GetMemberName(name)}";

        MemberDeclarationSyntax GetSolutionFolderPropertyDeclaration()
            => isSolution
                ? ParseMemberDeclaration($"private {typeof(Solution).FullName} SolutionFolder => this;")
                : ParseMemberDeclaration("private SolutionFolder SolutionFolder { get; }");

        MemberDeclarationSyntax GetSolutionFolderConstructorDeclaration(string parent)
            => ParseMemberDeclaration($"public {GetSolutionFolderTypeName(name, parent)}(SolutionFolder solutionFolder) => SolutionFolder = solutionFolder;");

        static MemberDeclarationSyntax GetProjectPropertyDeclaration(string name)
            => ParseMemberDeclaration($@"public Project {GetMemberName(name)} => SolutionFolder.GetProject(""{name}"");");

        static MemberDeclarationSyntax GetSolutionFolderProperty(string name, string parent)
            => ParseMemberDeclaration($@"public {GetSolutionFolderTypeName(name, parent)} {GetMemberName(name)} => new(SolutionFolder.GetSolutionFolder(""{name}""));");

        string GetParentName([CanBeNull] SolutionFolder solutionFolder) => $"{parent}_{GetMemberName(solutionFolder?.Name)}".TrimToOne("_");

        return ClassDeclaration(isSolution ? name : GetSolutionFolderTypeName(name, parent)) // TODO: check for multiple solution fields
            .AddModifiers(Token(SyntaxKind.InternalKeyword))
            .When(isSolution, syntax => syntax.AddBaseListTypes(SimpleBaseType(ParseTypeName(typeof(Solution).FullName.NotNull()))))
            .AddMembers(GetSolutionFolderPropertyDeclaration())
            .When(!isSolution, syntax => syntax.AddMembers(GetSolutionFolderConstructorDeclaration(parent)))
            .AddMembers(projects.Select(project => GetProjectPropertyDeclaration(project.Name)).ToArray())
            .AddMembers(solutionFolders.Select(x => GetSolutionFolderProperty(x.Name, GetParentName(x.SolutionFolder))).ToArray())
            .AddMembers(solutionFolders.Select(x => GetSolutionFolderDeclaration(x.Name, x.SolutionFolders, x.Projects, GetParentName(x.SolutionFolder)))
                .ToArray<MemberDeclarationSyntax>());
    }

    private static AbsolutePath GetSolutionFileFromParametersFile(AbsolutePath rootDirectory, string memberName)
    {
        var parametersFile = Constants.GetDefaultParametersFile(rootDirectory);
        Assert.FileExists(parametersFile);
        var jobject = JObject.Parse(File.ReadAllText(parametersFile));
        var solutionRelativePath = jobject[memberName].NotNull($"Property '{memberName}' does not exist in '{parametersFile}'.").Value<string>();
        return rootDirectory / solutionRelativePath.NotNull();
    }

    private static AbsolutePath GetRootDirectoryFrom(Compilation compilation)
    {
        var syntaxPath = compilation.SyntaxTrees.First().FilePath;
        var startDirectory = Path.GetDirectoryName(File.Exists(syntaxPath)
            ? syntaxPath
            // For testing only
            : Directory.GetCurrentDirectory());
        return Constants.TryGetRootDirectoryFrom(startDirectory).NotNull();
    }
}
